global
    log /dev/log local0
    log /dev/log local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
    user haproxy
    group haproxy
    daemon

defaults
    log global
    mode tcp
    option tcplog
    timeout connect 5s
    timeout client  50s
    timeout server  50s

frontend stats
    bind *:8404
    mode http
    stats enable
    stats uri /stats

frontend main_triage
    bind *:80
    bind *:443
    mode tcp
    
    # ‚ùå LIGNES SUPPRIM√âES POUR √âVITER LE LAG SUR LE PORT 80
    # On n'a pas besoin d'inspecter le SSL car on route selon le PORT, pas le DOMAINE.
    # tcp-request inspect-delay 5s
    # tcp-request content accept if { req_ssl_hello_type 1 }

    # ACL VPN
    acl source_is_vpn src {{ vpn_subnet }}

    # Routage HTTPS (Port 443)
    use_backend k8s_private_https if source_is_vpn { dst_port 443 }
    use_backend k8s_public_https  if { dst_port 443 }
    
    # Routage HTTP (Port 80)
    use_backend k8s_private_http  if source_is_vpn { dst_port 80 }
    default_backend k8s_public_http

# --- BACKENDS (NodePorts) ---

backend k8s_public_http
    mode tcp
    balance roundrobin
    # üëá On s'assure que la variable est bien 'worker_ips'
    {% for ip in worker_ips %}
    server w{{ loop.index }} {{ ip }}:30080 check
    {% endfor %}

backend k8s_public_https
    mode tcp
    balance roundrobin
    {% for ip in worker_ips %}
    server w{{ loop.index }} {{ ip }}:30443 check
    {% endfor %}

backend k8s_private_http
    mode tcp
    balance roundrobin
    {% for ip in worker_ips %}
    server w{{ loop.index }} {{ ip }}:31080 check
    {% endfor %}

backend k8s_private_https
    mode tcp
    balance roundrobin
    {% for ip in worker_ips %}
    server w{{ loop.index }} {{ ip }}:31443 check
    {% endfor %}
